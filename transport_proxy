#!/usr/bin/env python3

"""
Yandex Transport Monitor proxy service, automates getting data from Yandex.Transport using Selenium
"""

import time
import sys
import json
import signal
import socket
import datetime
import re
import threading
from collections import deque
from collections import defaultdict
from Logger import Logger
from YandexTransportCore import YandexTransportCore

# -------------------------------------------------------------------------------------------------------------------- #

class ListenerThread(threading.Thread):
    def __init__(self, conn, addr, app):
        super().__init__()
        self.conn = conn
        self.addr = addr

    def run(self):
        app.logger.info("Connection established : " + str(self.addr))

        while app.is_running:
            self.conn.settimeout(5)
            try:
                data = self.conn.recvfrom(4096)
            except socket.timeout:
                continue

            if data != (b'', None):
                string = data[0].decode("utf-8")
                lines = string.splitlines()
                for line in lines:
                    query = line.strip()
                    app.logger.debug("Received : " + str(query))

                    if query == "getCurrentQueue":
                        app.processGetCurrentQueue(self.conn)

                    elif query.startswith("getStopInfo?"):
                        app.processGetStopInfo(query, self.addr, self.conn)

                    elif query.startswith("getVehiclesInfo?"):
                        app.processGetStopInfo(query, self.addr, self.conn)

                    elif query.startswith("getRouteInfo?"):
                        app.processGetRouteInfo(query, self.addr, self.conn)

                    elif query.startswith("getAllInfo?"):
                        app.processGetRouteInfo(query, self.addr, self.conn)

                    elif query.startswith("echo?"):
                        app.processEcho(query, self.addr, self.conn)

                    else:
                        app.processUnknownQuery(self.conn)
            else:
                app.logger.info("Connection terminated : " + str(self.addr))
                break

        self.conn.shutdown(socket.SHUT_RDWR)
        app.logger.debug("Thread for connection ( " + str(self.addr) + " ) terminated")
        del app.listeners[self.addr]
# -------------------------------------------------------------------------------------------------------------------- #


class ExecutorThread(threading.Thread):
    def __init__(self, app):
        super().__init__()

        # Time to wait between queries
        self.wait_time = 5

    def send_message(self, message, addr, conn):
        try:
            app.logger.debug("Sending response to " + str(addr))
            conn.send(bytes(str(message) + '\n', 'utf-8'))
        except Exception as e:
            app.logger.error("Failed to send data to " + str(addr))

    def executeEcho(self, id, query, addr, conn):
        res = re.match("echo\?(.*)", query)
        if res is not None:
            # Send back echo query,
            # id: initial query ID
            # method: 'echo'
            # expect_more_data: False if no
            #                   True if yes
            # data:   actual data
            result = {'id': id,
                      'method': 'echo',
                      'expect_more_data': False,
                      'data': res.group(1)}
            result_json = json.dumps(result)
            self.send_message(result_json, addr, conn)


    def executeQuery(self, query):
        if query[0] < 0:
            return

        id = query[0]
        query_string = query[1]
        addr = query[2]
        conn = query[3]

        if query_string.startswith('echo?'):
            self.executeEcho(id, query_string, addr, conn)

    def run(self):
        app.logger.debug("Executor thread started, wait time between queries is "+str(self.wait_time)+" secs.")
        while app.is_running:
            # Default "discard" query
            query = (-1, '', '', None)
            app.queue_lock.acquire()
            query_len = len(app.query_queue)
            if query_len > 0:
                query = app.query_queue.popleft()
            app.queue_lock.release()

            self.executeQuery(query)

            for i in range(0, self.wait_time):
                if app.is_running:
                    time.sleep(1)
                else:
                    break
        app.logger.debug("Executor thread stopped")
# -------------------------------------------------------------------------------------------------------------------- #


class Application:
    """
    Main application class
    """
    def __init__(self):
        self.is_running = True
        # Listen address
        self.host = '127.0.0.1'
        self.port = 25555

        self.query_id = 0

        self.listeners = defaultdict()

        self.logger = Logger(Logger.DEBUG)

        # Queue lock
        self.queue_lock = threading.Lock()

        # Server will run in single thread, the deque is to store incoming queries.
        self.query_queue = deque()

    def sigint_handler(self, _signal, _time):
        """
        SIGINT signal handler
        :param _signal: signal
        :param _time: time
        :return: nothing
        """
        self.logger.info("SIGINT received! Terminating the program...")
        self.is_running = False
        self.logger.info("Waiting for threads to terminate...")
        copy_listeners = self.listeners.copy()
        for key, listener in copy_listeners.items():
            listener.join()
        if self.executor_thread is not None:
            self.executor_thread.join()

    def listen(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.settimeout(5)
        try:
            sock.bind((self.host, self.port))
        except socket.error:
            return 1

        self.logger.info("Listening for incoming connections.")
        self.logger.info("Host: " + str(self.host) + " , Port: " + str(self.port))
        sock.listen(1)

        while self.is_running:
            try:
                conn, addr = sock.accept()
            except socket.timeout:
                continue

            listener_thread = ListenerThread(conn, addr, self)
            self.listeners[addr] = listener_thread
            listener_thread.start()

        sock.shutdown(socket.SHUT_RDWR)

        return 0

    def getCurrentConnections(self):
        data = []
        for key, value in self.listeners.items():
            entry = {"ip_address" : key[0], "port" : key[1]}
            data.append(entry)
        json_data = json.dumps(data)

        return json_data

    def getCurrentQueue(self):
        data = []

        self.queue_lock.acquire()
        for line in self.query_queue:
            entry = {"id": line[0], "query": line[1]}
            data.append(entry)
        self.queue_lock.release()

        json_data = json.dumps(data)

        return json_data

    def processGetInfo(self, query, addr, conn):

        self.queue_lock.acquire()
        app.query_queue.append((self.query_id, query, addr, conn))
        queue_position = len(app.query_queue) - 1
        self.queue_lock.release()

        response = {"id": self.query_id,
                    "response": "OK",
                    "queue_position": queue_position}
        response_json = json.dumps(response)
        conn.send(bytes(response_json + '\n', 'utf-8'))
        self.query_id += 1

    def processGetStopInfo(self, query, addr, conn):
        self.processGetInfo(query, addr, conn)

    def processGetVehiclesInfo(self, query, addr, conn):
        self.processGetInfo(query, addr, conn)

    def processGetRouteInfo(self, query, addr, conn):
        self.processGetInfo(query, addr, conn)

    def processGetAllInfo(self, query, addr, conn):
        self.processGetInfo(query, addr, conn)

    def processEcho(self, query, addr, conn):
        self.processGetInfo(query, addr, conn)

    def processGetCurrentQueue(self, conn):
        current_queue = app.getCurrentQueue()
        conn.send(bytes(current_queue + '\n', 'utf-8'))

    def processUnknownQuery(self, conn):
        response = {"response": "ERROR", "message": "Unknown query"}
        response_json = json.dumps(response)
        conn.send(bytes(response_json + "\n", 'utf-8'))

    def run(self):
        """
        Run the application
        :return: exit code
        """

        self.logger.info("YTPS - Yandex Transport Proxy Server - starting up...")

        signal.signal(signal.SIGINT, self.sigint_handler)

        # Starting query executor thread
        self.executor_thread = ExecutorThread(self)
        self.executor_thread.start()

        core = YandexTransportCore()
        core.startWebdriver()

        # Getting stop info example
        """
        res = core.getStopInfo(url="https://yandex.ru/maps/213/moscow/?"
                                   "ll=37.579537,C55.821644&"
                                   "masstransit[stopId]=stop__9639753&"
                                   "mode=stop&"
                                   "z=16")
        # Printing the output
        print(json.dumps(res, sort_keys=True, indent=4, separators=(',', ': ')))
        time.sleep(5)

        # Getting vehicles info example
        res = core.getVehiclesInfo(url="https://yandex.ru/maps/213/moscow/?"
                                       "ll=37.589633%2C55.835559&"
                                       "masstransit[routeId]=213_56_trolleybus_mosgortrans&"
                                       "masstransit[stopId]=stop__9639753&"
                                       "masstransit[threadId]=213A_56_trolleybus_mosgortrans&"
                                       "mode=stop&"
                                       "z=14")
        # Printing the output
        print(json.dumps(res, sort_keys=True, indent=4, separators=(',', ': ')))
        """
        self.listen()

        core.stopWebdriver()

        self.logger.info("YTPS - Yandex Transport Proxy Server - terminated!")

# -------------------------------------------------------------------------------------------------------------------- #
if __name__ == '__main__':
    app = Application()
    app.run()
    sys.exit(0)
